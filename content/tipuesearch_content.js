var tipuesearch = {"pages": [{'title': '個人網站', 'text': '大家好 \n 我是一個喜歡動手做的大學生 \n 平時也喜歡玩國樂 \n 你現在看到的是我在大學甚至未來或者過去的一些紀錄 \n 若想要跟我聯絡的可以寄信到lin.hybrian@gmail.com \n 我看到就會回喔 \n \n 上圖為我任職於國樂社第39屆社長時拍的照片', 'tags': '', 'url': '個人網站.html'}, {'title': '二下', 'text': '', 'tags': '', 'url': '二下.html'}, {'title': 'arduino 機械手臂', 'text': '概述: \n 用PS2手把控制，可以使用arduino有一個PS2的函式庫(PS2X_lib.h)進行控制 \n 馬達的部分是使用MG996R進行控制 \n 又因為馬達需要額外供電所以會有一個額外的5V供電\xa0 \n \n files: \n https://github.com/Blinhy0131/Arduino-robot-arm \n 材質:3D列印 \n \n 電路圖參考 \n \n \n', 'tags': '', 'url': 'arduino 機械手臂.html'}, {'title': 'CoppliaSim程式模擬', 'text': '一開始的時候覺得Coppelasim好像沒有什麼 \n 但是在越用越多的時候 \n 發現Coppelasim好像比想像中的還要重要 \n 可以在電腦模擬出幾近真實的機械手臂運動 \n 我期許我未來能在自己學習有關Coppeliasim的相關應用', 'tags': '', 'url': 'CoppliaSim程式模擬.html'}, {'title': '架設場景', 'text': '', 'tags': '', 'url': '架設場景.html'}, {'title': '對軸進行旋轉控制', 'text': '使用coppeliaSim\xa0先叫出一個簡單的軸 \n 來進行模擬控制 \n \n \n', 'tags': '', 'url': '對軸進行旋轉控制.html'}, {'title': '對方快進行XYZ軸控制', 'text': "\n 建立方塊並且對其進行XYZ軸控制 \n \n \n 程式碼如下 \n function sysCall_init()\n    joint01=sim.getObjectHandle('joint01')\n    joint02=sim.getObjectHandle('joint02')\n    joint03=sim.getObjectHandle('joint03')\n    set=0\n    set1=0\n    set2=0\nend\n\nfunction sysCall_actuation()\n    -- put your actuation code here\n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then\n            if (auxiliaryData[1]==2009) then\n                set=set+0.01\n                sim.setJointTargetPosition(joint01,set)\n            end\n            if (auxiliaryData[1]==2010) then\n                set=set-0.01\n                sim.setJointTargetPosition(joint01,set)\n            end\n            if (auxiliaryData[1]==2007) then\n               set1=set1+0.01\n               sim.setJointTargetPosition(joint02,set1)\n            end\n           if (auxiliaryData[1]==2008) then\n              set1=set1-0.01\n              sim.setJointTargetPosition(joint02,set1)\n            end\n            if (auxiliaryData[1]==50) then\n               set2=set2+0.01\n               sim.setJointTargetPosition(joint03,set2)\n            end\n           if (auxiliaryData[1]==56) then\n              set2=set2-0.01\n              sim.setJointTargetPosition(joint03,set2)\n            end\n        end\n    message,auxiliaryData=sim.getSimulatorMessage()\n    end\nend \n \n", 'tags': '', 'url': '對方快進行XYZ軸控制.html'}, {'title': '物件螺旋運動', 'text': "使用現成 腳本使方塊進行螺旋運動 \n \n code \n function sysCall_threadmain()\n    jointx=sim.getObjectHandle('01')\n    jointy=sim.getObjectHandle('02')\n    jointz=sim.getObjectHandle('03')\n    high=0\n    \n    for cycle=0,36000,1 do\n        sim.setJointTargetPosition(jointx,0.3*(math.sin(cycle*math.pi/180)))\n        sim.wait(0.01)\n        sim.setJointTargetPosition(jointy,0.3*(math.cos(cycle*math.pi/180)))\n        sim.wait(0.01)\n        high=high+0.001\n        sim.setJointTargetPosition(jointz,high)\n        sim.wait(0.01)\n        \n    end\nend \n \n", 'tags': '', 'url': '物件螺旋運動.html'}, {'title': '3D列印機_控制噴嘴', 'text': "\n 控制: \n 上下左右控制噴頭的上下左右 \n 空白鍵往上 \n C鍵往下 \n \n \n 圖檔下載 \n 3D print.ttt \n \n \n 程式參考 \n function sysCall_init()\n    joint01=sim.getObjectHandle('X')\n    joint02=sim.getObjectHandle('Y')\n    joint03=sim.getObjectHandle('Z')\n    set=0\n    set1=0\n    set2=0\n    s=0.005\nend\n\nfunction sysCall_actuation()\n    -- put your actuation code here\n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then\n            if (auxiliaryData[1]==2009) then\n                set=set+s\n                sim.setJointTargetPosition(joint01,set)\n                print(sim.getJointPosition(joint01))\n            end\n            if (auxiliaryData[1]==2010) then\n                set=set-s\n                sim.setJointTargetPosition(joint01,set)\n            end\n            if (auxiliaryData[1]==2007) then\n               set1=set1+s\n               sim.setJointTargetPosition(joint02,set1)\n            end\n           if (auxiliaryData[1]==2008) then\n              set1=set1-s\n              sim.setJointTargetPosition(joint02,set1)\n            end\n            if (auxiliaryData[1]==32) then\n               set2=set2+s\n               sim.setJointTargetPosition(joint03,set2)\n            end\n           if (auxiliaryData[1]==99) then\n              set2=set2-s\n              sim.setJointTargetPosition(joint03,set2)\n            end\n        end\n    message,auxiliaryData=sim.getSimulatorMessage()\n    end\nend \n \n", 'tags': '', 'url': '3D列印機_控制噴嘴.html'}, {'title': '3D列印機_自動繪製', 'text': "自動繪製正方體 \n 3D print AutoControl cube.ttt \n 自動繪製圓柱體 \n 3D print AutoControl circle.ttt \n 自動繪製心臟線 \n 3D print AutoControl Cardioid.ttt \n 參考影片 \n \n 程式參考: \n 1.正方體 \n find_Position=function()\nXYZ={xp, yp, zz, step}\nend\nfunction sysCall_threadmain()\n    joint01=sim.getObjectHandle('X')\n    joint02=sim.getObjectHandle('Y')\n    joint03=sim.getObjectHandle('Z')\n    grap=sim.getObjectHandle('Graph')\n    set=0\n    set1=0\n    set2=0\n    s=0.01\n    step=1\n    xp=0\n    yp=0\n    zz=0\n    xstep=0\n    ystep=0\n    zstep=0\n    cubesize=10\n    t=1\n    \n    \n    while zstep<=cubesize do\n        while step<cubesize do --go++\n            while xstep<=step do\n                xp=xp+s\n                sim.setJointTargetPosition(joint01,xp)\n                find_Position()\n                print(XYZ)\n                xstep=xstep+1\n                sim.wait(t)\n            end\n            while ystep<=step do\n                yp=yp+s\n                sim.setJointTargetPosition(joint02,yp)\n                find_Position()\n                print(XYZ)\n                ystep=ystep+1\n                sim.wait(t)\n            end\n            --step=step+1\n            xstep=0\n            ystep=0    \n            while xstep<=step do\n                xp=xp-s\n                sim.setJointTargetPosition(joint01,xp)\n                find_Position()\n                print(XYZ)\n                xstep=xstep+1\n                sim.wait(t)\n            end\n            while ystep<=step do --go--\n                yp=yp-s\n                sim.setJointTargetPosition(joint02,yp)\n                find_Position()\n                print(XYZ)\n                ystep=ystep+1\n                sim.wait(t)\n            end\n            if step < (cubesize-1) then\n                xp=xp-0.5*s\n                yp=yp-0.5*s\n                sim.setJointTargetPosition(joint01,xp)\n                sim.setJointTargetPosition(joint02,yp)\n                find_Position()\n                print(XYZ)\n            end\n            step=step+1\n            sim.wait(t)\n            xstep=0\n            ystep=0\n        end\n        step=1\n        zz=zz+s\n        sim.setJointTargetPosition(joint03,zz)\n        find_Position()\n        print(XYZ)\n        zstep=zstep+1\n        sim.wait(t)\n        xp=0\n        yp=0\n        sim.setJointTargetPosition(joint01,xp)\n        sim.setJointTargetPosition(joint02,yp)\n        find_Position()\n        print(XYZ)\n        sim.wait(t)\n    end\n    \nend\n\nfunction sysCall_cleanup()\n      \n    \nend\n\n-- See the user manual or the available code snippets for additional callback functions and details\n \n 2. 圓柱體 \n function sysCall_threadmain()\n    joint01=sim.getObjectHandle('X')\n    joint02=sim.getObjectHandle('Y')\n    joint03=sim.getObjectHandle('Z')\n    grap=sim.getObjectHandle('Graph')\n    set=0\n    set1=0\n    set2=0\n    s=0.01\n    step=1\n    r=0.005\n    rset=0.01\n    zz=0\n    zstep=1\n    dz=0.01\n    rstep=1\n    cubesize=10\n    t=0.01\n    angle=0\n    angleset=2\n    \nend\n\nfunction sysCall_cleanup()\n    while zstep<=20 do\n        while rstep<=5 do\n            while angle~=360 do\n                angle=angle+angleset\n                sim.setJointTargetPosition(joint01,r*(math.sin(angle*math.pi/180)))\n                sim.setJointTargetPosition(joint02,r*(math.cos(angle*math.pi/180)))\n                sim.wait(t)\n            end\n        rstep=rstep+1\n        angle=0\n        r=r+rset\n        print(rstep)\n        end\n    zz=zz+dz\n    zstep=zstep+1\n    sim.setJointTargetPosition(joint03,zz)\n    sim.setJointTargetPosition(joint01,0)\n    sim.setJointTargetPosition(joint02,0)\n    rstep=1\n    r=0.005\n    end\n    \nend\n\n-- See the user manual or the available code snippets for additional callback functions and details\n \n 3. 心臟線 \n function sysCall_threadmain()\n    joint01=sim.getObjectHandle('X')\n    joint02=sim.getObjectHandle('Y')\n    joint03=sim.getObjectHandle('Z')\n    grap=sim.getObjectHandle('Graph')\n    set=0\n    set1=0\n    set2=0\n    s=0.01\n    step=1\n    r=0.005\n    rset=0.001\n    zz=0\n    zstep=1\n    dz=0.001\n    rstep=1\n    cubesize=10\n    t=0.5\n    angle=0\n    angleset=2\n    \nend\n\nfunction sysCall_cleanup()\n    while zstep<=30 do\n        while rstep<=30 do\n            while angle~=360 do\n                angle=angle+angleset\n                sim.setJointTargetPosition(joint01,2*r*((math.cos(angle*math.pi/180))-0.5*(math.cos(2*angle*math.pi/180))))\n                sim.setJointTargetPosition(joint02,2*r*((math.sin(angle*math.pi/180))-0.5*(math.sin(2*angle*math.pi/180))))\n                sim.wait(t)\n            end\n        rstep=rstep+1\n        angle=0\n        r=r+rset\n        print(rstep)\n        end\n    zz=zz+dz\n    zstep=zstep+1\n    sim.setJointTargetPosition(joint03,zz)\n    sim.setJointTargetPosition(joint01,0)\n    sim.setJointTargetPosition(joint02,0)\n    rstep=1\n    r=0.005\n    end\n    \nend\n\n \n \n", 'tags': '', 'url': '3D列印機_自動繪製.html'}, {'title': '3D列印機_控制高度', 'text': "\n 控制: \n 上下左右控制噴頭的上下左右 \n 空白鍵往上 \n C鍵往下 \n \n \n 圖檔下載 \n 3D print control altitude.ttt \n \n 影片參考 \n \n 程式參考: \n function sysCall_init()\n    -- do some initialization here\n    joint1=sim.getObjectHandle('P1')\n    joint2=sim.getObjectHandle('P2')\n    joint3=sim.getObjectHandle('P3')\n    xp=0\n    yp=0\n    zp=0\n    p1p=0\n    p2p=0\n    p3p=0\n    dz=0\n    step=0.01\n    --sim.getJointTargetPosition(joint1,p1p)\n    --sim.getJointTargetPosition(joint2,p2p)\n    --sim.getJointTargetPosition(joint3,p3p)\n    H=((0.290)^2-(0.1325)^2)^(1/2)\n    BaseX=0.1325*(math.cos(60*math.pi/180))\n    BaseY2=0.1325*(math.sin(60*math.pi/180))\n    BaseY3=0.1325*(math.sin(60*math.pi/180))\nend\n\nxyz = function()\n    bar1=(((0.290)^2-(0.1325-xp)^2-yp^2)^(1/2)-H+dz)\n    bar2=(((0.290)^2-BaseX^2-BaseY2^2)^(1/2)-H+dz)\n    bar3=(((0.290)^2-BaseX^2-BaseY3^2)^(1/2)-H+dz)\nend\n\nfunction sysCall_actuation()\n    -- put your actuation code here\n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then\n            if (auxiliaryData[1]==2010) then\n                xp=xp+step\n                BaseX=BaseX+step\n                xyz()\n                sim.setJointTargetPosition(joint1,bar1)\n                sim.setJointTargetPosition(joint2,bar2)\n                sim.setJointTargetPosition(joint3,bar3)\n            end\n            if (auxiliaryData[1]==2009) then\n                xp=xp-step\n                BaseX=BaseX-step\n                xyz()\n                sim.setJointTargetPosition(joint1,bar1)\n                sim.setJointTargetPosition(joint2,bar2)\n                sim.setJointTargetPosition(joint3,bar3)\n            end\n            if (auxiliaryData[1]==2007) then\n                yp=yp+step\n                BaseY2=BaseY2-step\n                BaseY3=BaseY3+step\n                xyz()\n                sim.setJointTargetPosition(joint1,bar1)\n                sim.setJointTargetPosition(joint2,bar2)\n                sim.setJointTargetPosition(joint3,bar3)\n            end\n            if (auxiliaryData[1]==2008) then\n                yp=yp-step\n                BaseY2=BaseY2+step\n                BaseY3=BaseY3-step\n                xyz()\n                sim.setJointTargetPosition(joint1,bar1)\n                sim.setJointTargetPosition(joint2,bar2)\n                sim.setJointTargetPosition(joint3,bar3)\n            end\n            if (auxiliaryData[1]==32) then\n                sim.getJointTargetPosition(joint1,p1p)\n                sim.getJointTargetPosition(joint2,p2p)\n                sim.getJointTargetPosition(joint3,p3p)\n                p1p=p1p+dz\n                p2p=p2p+dz\n                p3p=p3p+dz\n                dz=dz+step\n                printf(p1p)\n                xyz()\n                print(p2p)\n                sim.setJointTargetPosition(joint1,bar1+dz)\n                sim.setJointTargetPosition(joint2,bar2+dz)\n                sim.setJointTargetPosition(joint3,bar3+dz)\n                H=H-dz\n            end\n            if (auxiliaryData[1]==99) then\n                sim.getJointTargetPosition(joint1,p1p)\n                sim.getJointTargetPosition(joint2,p2p)\n                sim.getJointTargetPosition(joint3,p3p)\n                p1p=p1p-dz\n                p2p=p2p-dz\n                p3p=p3p-dz\n                dz=dz-step\n                printf(p1p)\n                xyz()\n                print(p2p)\n                sim.setJointTargetPosition(joint1,bar1-dz)\n                sim.setJointTargetPosition(joint2,bar2-dz)\n                sim.setJointTargetPosition(joint3,bar3-dz)\n                H=H-dz\n            end\n         end\nmessage,auxiliaryData=sim.getSimulatorMessage()\nend\n    \nend\n\nfunction sysCall_sensing()\n    -- put your sensing code here\nend\n\nfunction sysCall_cleanup()\n    -- do some clean-up here\nend\n\n-- See the user manual or the available code snippets for additional callback functions and details\n \n \n \n", 'tags': '', 'url': '3D列印機_控制高度.html'}, {'title': '衝擊試驗機', 'text': "控制說明 \n 請依序按下1~4 \n 分別為上升、落下、往下、接合 \n \n \n 程式碼參考 \n function sysCall_init()\n    -- do some initialization here\n    jointY=sim.getObjectHandle('Prismatic_joint')\n    joint1=sim.getObjectHandle('Prismatic_joint0')\n    joint2=sim.getObjectHandle('Prismatic_joint1')\n    cont=1\nend\n\nfunction sysCall_actuation()\n    -- put your actuation code here\n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then\n            if (auxiliaryData[1]==49) then\n                if (cont==1) then\n                    sim.setJointTargetPosition(jointY,40)\n                    cont=2\n                end\n            end\n            if (auxiliaryData[1]==50) then\n                if (cont==2) then\n                    sim.setJointTargetPosition(joint1,0.1)\n                    sim.setJointTargetPosition(joint2,-0.1)\n                    cont=3\n                end\n            end\n            if (auxiliaryData[1]==51) then\n                if (cont==3) then\n                    sim.setJointTargetPosition(jointY,0)\n                    cont=4\n                end\n            end\n            if (auxiliaryData[1]==52) then\n                if (cont==4) then\n                    sim.setJointTargetPosition(joint1,0)\n                    sim.setJointTargetPosition(joint2,0)\n                    cont=1\n                end\n            end\n         end\n    message,auxiliaryData=sim.getSimulatorMessage()\n    end\nend\n\nfunction sysCall_sensing()\n    -- put your sensing code here\nend\n\nfunction sysCall_cleanup()\n    -- do some clean-up here\nend\n\n-- See the user manual or the available code snippets for additional callback functions and details\n \n \n", 'tags': '', 'url': '衝擊試驗機.html'}, {'title': '架設機械手臂場景', 'text': '將所有物件控制後直接進行模擬，檢測是否有異樣 \n \n', 'tags': '', 'url': '架設機械手臂場景.html'}, {'title': '機械手臂場景微調', 'text': '嘗試使用程式控制 \n 但是還是會亂跑 \n \n \n \n', 'tags': '', 'url': '機械手臂場景微調.html'}, {'title': '機械手臂場景路徑控制', 'text': '勉強可以控制路徑了(預先設定 \n \n \n', 'tags': '', 'url': '機械手臂場景路徑控制.html'}, {'title': 'W13 Pick and Place', 'text': '\n 課程要求 \n \n', 'tags': '', 'url': 'W13 Pick and Place.html'}, {'title': 'remoteApi', 'text': '\n 請見task2-remoteApi->W13 remoteApi \n 傳送門 \n', 'tags': '', 'url': 'remoteApi.html'}, {'title': '0526更新', 'text': '預計更新-remoteApi \n 檔案下載 \n W13_pick and place \n 影片: \n 影片模擬時間為30分鐘，總共進行4次將球放到空盤再回復，理論上可以無限反覆模擬 \n \n 之前在舊版本中，會發現吸盤一直朝同一方向旋轉角度會誤差越來越大，所以在此場景中，將吸取設為正轉，放下設成反轉，即可以避免朝同一方向選轉造成的角度偏移問題 \n 程式構想: \n 透過計算現在為拿取第幾個球，可以推算出該球在第幾層(unit)，也可以定為該層的起始座標(角落) \n 知道在第幾層後可以反推出他是該層的第幾個(finding_XY)，進一步知道他的XY座標(X_Pos/Y_Pos) \n 例: 第九顆球，可以得知在第三層，反推可以得知她是第4個，然後就可以得知她是第二排第一個，以此類推 \n 而在第30顆球過後，需要重新設定基準座標還有重設數量，才有最下面if問句 \n 程式參考 \n function signal_switch(singal,enable)\n    if singal==1 or singal==12 then\n        sim.setIntegerSignal(modelName1 .."call_1",enable)\n    end\n    if singal==2 or singal==11 then\n        sim.setIntegerSignal(modelName2 .."call_2",enable)\n    end\n    if singal==3 or singal==10 then\n        sim.setIntegerSignal(modelName3 .."call_3",enable)\n    end\n    if singal==4 or singal==9 then\n        sim.setIntegerSignal(modelName4 .."call_4",enable)\n    end\n    if singal==5 or singal==8 then\n        sim.setIntegerSignal(modelName5 .."call_5",enable)\n    end\n    if singal==6 or singal==7 then\n        sim.setIntegerSignal(modelName6 .."call_6",enable)\n    end\nend\n\nfunction sysCall_threadmain()\n    joint01=sim.getObjectHandle(\'X\')\n    joint02=sim.getObjectHandle(\'Y\')\n    joint03=sim.getObjectHandle(\'Z\')\n    jointr=sim.getObjectHandle(\'Rotate\')\n    tt=1\n    long_t=1.5\n    long_long_t=3 --time set\n    rotate_deg=0 --pad rotate\n    atz=0  --altitude set\n    setx=0.5\n    setpx=-0.5 --center pick set\n    sety=-0.16\n    setpy=-0.16 --center fall set\n    local pick_high={"0.0645","0.134","0.2025","0.2768"} --pick up high set\n    local fall_high={"0.05","0.12","0.18","0.26"} --fall high set\n    local high_up={"0","0","0.05","0.12"}\n    cube=1              -- set cube\n    ball_pick_time=0    --total ball we pick\n    ball_put_time=31     --total ball we put\n    while (ball_pick_time<60) do\n        for ball=1,6,1 do    --pick the ball\n            ball_pick_time=ball_pick_time+1 --total time we pick\n            i=1\n            unit=0\n            level=0\n            while level < ball_pick_time do  --find which level and place should be of the xy coordinates\n                unit=unit+1\n                level=level+unit^2\n            end\n            finding_XY=ball_pick_time   --this is the XY on that floor\n            while(i<=unit-1) do            \n                finding_XY=finding_XY-(i^2) \n                i=i+1\n            end\n            X_Pos=finding_XY%unit       -- the X and Y coordinates(by balls)\n             if X_Pos==0 then\n                X_Pos=unit\n            end\n            Y_Pos=(math.ceil(finding_XY/unit)) \n            BaseX=setx-((unit-1)*0.05)--now we need to find the 0 of the xy\n            BaseY=sety-((unit-1)*0.05)\n            sim.setJointTargetPosition(joint01,BaseX+(0.1*(X_Pos-1))) --move to Position\n            sim.wait(tt)\n            sim.setJointTargetPosition(joint02,BaseY+(0.1*(Y_Pos-1)))\n            sim.wait(tt)\n            signal_switch(ball,1) --switch pad on\n            sim.setJointTargetPosition(joint03,-pick_high[unit])--pick the pall\n            sim.wait(tt)\n            sim.setJointTargetPosition(joint03,atz-high_up[unit]) --after pick up we dont need to go that high\n            sim.wait(tt)\n            rotate_deg=rotate_deg+60  --rotate the pad\n            sim.setJointTargetPosition(jointr,rotate_deg*math.pi/180)\n            sim.wait(tt)\n            sim.wait(tt)\n        end\n        sim.wait(long_t)\n        sim.setJointTargetPosition(joint01,0)\n        sim.setJointTargetPosition(joint02,0)\n        sim.setJointTargetPosition(joint03,0)\n        sim.wait(long_t)\n        for ball=1,6,1 do --put the ball\n            ball_put_time=ball_put_time-1\n            i=1\n            unit=0\n            level=0\n            while level < ball_put_time do  --find which level and place should be of the xy coordinates\n                unit=unit+1\n                level=level+unit^2\n            end\n            finding_XY=ball_put_time   --this is the XY on that floor\n            while(i<=unit-1) do            \n                finding_XY=finding_XY-(i^2) \n                i=i+1\n            end\n            X_Pos=finding_XY%unit       -- the X and Y coordinates(by balls)\n             if X_Pos==0 then\n                X_Pos=unit\n            end\n            Y_Pos=(math.ceil(finding_XY/unit)) \n            BaseX=setpx-((unit-1)*0.05)--now we need to find the 0 of the xy\n            BaseY=setpy-((unit-1)*0.05)\n            rotate_deg=rotate_deg-60  --rotate the pad\n            sim.setJointTargetPosition(jointr,rotate_deg*math.pi/180)\n            sim.wait(tt)\n            sim.setJointTargetPosition(joint01,BaseX+(0.1*(X_Pos-1))) --move to Position\n            sim.wait(tt)\n            sim.setJointTargetPosition(joint02,BaseY+(0.1*(Y_Pos-1)))\n            sim.wait(tt)\n            sim.setJointTargetPosition(joint03,-fall_high[unit])--pick the pall\n            sim.wait(tt)\n            signal_switch(ball+6,0) --switch pad off\n            sim.wait(tt)\n            sim.setJointTargetPosition(joint03,atz-high_up[unit]) --after pick up we dont need to go that high\n            sim.wait(tt)\n            sim.wait(tt)\n        end\n        sim.wait(long_t)\n        sim.setJointTargetPosition(joint01,0)\n        sim.setJointTargetPosition(joint02,0)\n        sim.setJointTargetPosition(joint03,0)\n        sim.wait(long_t)\n        if ball_pick_time==30 then\n            pick_high={"0.07","0.138","0.2085","0.28"}\n            setx=-setx\n            setpx=-setpx\n            ball_pick_time=0\n            ball_put_time=31\n        end\n    end\nend \n \n', 'tags': '', 'url': '0526更新.html'}, {'title': '舊版本', 'text': '預計更新內容:將簡化程式碼 \n 圖檔: \n W13 Pick and Place.ttt \n 5/21 拍攝 \n \n \n 程式碼參考 \n 主程式 \n function signal_on()\n    signal_1(true)\n    signal_2(true)\n    signal_3(true)\n    signal_4(true)\n    signal_5(true)\n    signal_6(true)\nend\n\nfunction signal_1(enable)\n    modelBase1=sim.getObjectAssociatedWithScript(sim.handle_self)\n    modelName1=sim.getObjectName(modelBase1)\n    if enable then\n        sim.setIntegerSignal(modelName1 .."call_1",1)\n    else\n        sim.setIntegerSignal(modelName1 .."call_1",0)\n    end\nend\n\nfunction signal_2(enable)\n    modelBase2=sim.getObjectAssociatedWithScript(sim.handle_self)\n    modelName2=sim.getObjectName(modelBase2)\n    if enable then\n        sim.setIntegerSignal(modelName2 .."call_2",1)\n    else\n        sim.setIntegerSignal(modelName2 .."call_2",0)\n    end\nend\n\nfunction signal_3(enable)\n    modelBase3=sim.getObjectAssociatedWithScript(sim.handle_self)\n    modelName3=sim.getObjectName(modelBase3)\n    if enable then\n        sim.setIntegerSignal(modelName3 .."call_3",1)\n    else\n        sim.setIntegerSignal(modelName3 .."call_3",0)\n    end\nend\n\nfunction signal_4(enable)\n    modelBase4=sim.getObjectAssociatedWithScript(sim.handle_self)\n    modelName4=sim.getObjectName(modelBase4)\n    if enable then\n        sim.setIntegerSignal(modelName4 .."call_4",1)\n    else\n        sim.setIntegerSignal(modelName4 .."call_4",0)\n    end\nend\n\nfunction signal_5(enable)\n    modelBase5=sim.getObjectAssociatedWithScript(sim.handle_self)\n    modelName5=sim.getObjectName(modelBase5)\n    if enable then\n        sim.setIntegerSignal(modelName5 .."call_5",1)\n    else\n        sim.setIntegerSignal(modelName5 .."call_5",0)\n    end\nend\n\nfunction signal_6(enable)\n\n\n    modelBase6=sim.getObjectAssociatedWithScript(sim.handle_self)\n    modelName6=sim.getObjectName(modelBase6)\n    if enable then\n        sim.setIntegerSignal(modelName6 .."call_6",1)\n    else\n        sim.setIntegerSignal(modelName6 .."call_6",0)\n    end\nend\n\n\nfunction sysCall_threadmain()\n    on=true\n    joint01=sim.getObjectHandle(\'X\')\n    joint02=sim.getObjectHandle(\'Y\')\n    joint03=sim.getObjectHandle(\'Z\')\n    jointr=sim.getObjectHandle(\'Rotate\')\n    secc=sim.getScriptHandle(\'suctionPad\')\n    dx=0\n    dy=0\n    dz=0\n    dr=0\n    dt=0.01\n    tt=1\n    long_t=1.5\n    long_long_t=3\n    aty=0\n    setx=0.5\n    setpx=-0.5\n    sety=-0.16\n    setpy=-0.16\n    pick_h1=0.0645\n    pick_h2=0.134\n    pick_h3=0.2025\n    pick_h4=0.2768\n    fall_h4=0.26\n    fall_h3=0.18\n    fall_h2=0.12\n    fall_h1=0.05\n    fall_h4_up=0.12\n    fall_h3_up=0.05\n    while (on==true) do\n    signal_1(true)\n    sim.setJointTargetPosition(joint01,setx) --pick_1\n    sim.setJointTargetPosition(joint02,sety)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.05) --pick_2 h2-h2-\n    sim.setJointTargetPosition(joint02,sety-0.05)\n    sim.wait(tt)\n    signal_2(true)\n    sim.setJointTargetPosition(joint03,aty-pick_h2)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.05) --pick_3\n    sim.setJointTargetPosition(joint02,sety+0.05)\n    sim.wait(tt)\n    signal_3(true)\n    sim.setJointTargetPosition(joint03,aty-pick_h2)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.05) --pick_4\n    sim.setJointTargetPosition(joint02,sety+0.05)\n    sim.wait(tt)\n    signal_4(true)\n    sim.setJointTargetPosition(joint03,aty-pick_h2)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.05) --pick_5\n    sim.setJointTargetPosition(joint02,sety-0.05)\n    sim.wait(tt)\n    signal_5(true)\n    sim.setJointTargetPosition(joint03,aty-pick_h2)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.1) --pick_6 h3-h3\n    sim.setJointTargetPosition(joint02,sety+0.1)\n    sim.wait(tt)\n    signal_6(true)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(long_t)\n    -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setpx-0.15)--fall 1\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint02,setpy+0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_1(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.15)--fall 2\n    sim.setJointTargetPosition(joint02,setpy+0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_2(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.15)--fall 3\n    sim.setJointTargetPosition(joint02,setpy-0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_3(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.15)--fall 4\n    sim.setJointTargetPosition(joint02,setpy-0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_4(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.05)--fall 5\n    sim.setJointTargetPosition(joint02,setpy-0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_5(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.05)--fall 6\n    sim.setJointTargetPosition(joint02,setpy-0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_6(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) \n    sim.setJointTargetPosition(joint02,sety)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setx+0.1) --pick_7\n    sim.setJointTargetPosition(joint02,sety)\n    signal_1(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.1) --pick_8\n    sim.setJointTargetPosition(joint02,sety-0.1)\n    signal_2(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) --pick_9\n    sim.setJointTargetPosition(joint02,sety-0.1)\n    signal_3(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) --pick_10\n    sim.setJointTargetPosition(joint02,sety)\n    signal_4(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) --pick_11\n    sim.setJointTargetPosition(joint02,sety+0.1)\n    signal_5(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.1) --pick_12\n    sim.setJointTargetPosition(joint02,sety+0.1)\n    signal_6(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(long_t)\n     -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setpx-0.05)--fall 7\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint02,setpy+0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_1(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.05)--fall 8\n    sim.setJointTargetPosition(joint02,setpy+0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_2(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-0.12)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.05)--fall 9\n    sim.setJointTargetPosition(joint02,setpy+0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_3(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.05)--fall 10\n    sim.setJointTargetPosition(joint02,setpy+0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_4(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.05)--fall 11\n    sim.setJointTargetPosition(joint02,setpy-0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_5(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.05)--fall 12\n    sim.setJointTargetPosition(joint02,setpy-0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_6(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) \n    sim.setJointTargetPosition(joint02,sety)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setx-0.1) --pick_13\n    sim.setJointTargetPosition(joint02,sety)\n    signal_1(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.1) --pick_14 \n    sim.setJointTargetPosition(joint02,sety-0.1)\n    signal_2(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.15) --pick_15 --h4-h4\n    sim.setJointTargetPosition(joint02,sety+0.15)\n    signal_3(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.15) --pick_16\n    sim.setJointTargetPosition(joint02,sety+0.05)\n    signal_4(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.15) --pick_17\n    sim.setJointTargetPosition(joint02,sety-0.05)\n    signal_5(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.15) --pick_18\n    sim.setJointTargetPosition(joint02,sety-0.15)\n    signal_6(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(long_t)\n     -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setpx+0.15)--fall 13\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint02,setpy-0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_1(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.15)--fall 14\n    sim.setJointTargetPosition(joint02,setpy-0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_2(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.15)--fall 15\n    sim.setJointTargetPosition(joint02,setpy+0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_3(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.15)--fall 16\n    sim.setJointTargetPosition(joint02,setpy+0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_4(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.1)--fall 17 h3--h3\n    sim.setJointTargetPosition(joint02,setpy-0.1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_5(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.1)--fall 18\n    sim.setJointTargetPosition(joint02,setpy-0)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_6(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) \n    sim.setJointTargetPosition(joint02,sety)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setx-0.05) --pick_19\n    sim.setJointTargetPosition(joint02,sety-0.15)\n    signal_1(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.05) --pick_20 \n    sim.setJointTargetPosition(joint02,sety-0.05)\n    signal_2(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.05) --pick_21\n    sim.setJointTargetPosition(joint02,sety+0.05)\n    signal_3(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.05) --pick_22\n    sim.setJointTargetPosition(joint02,sety+0.15)\n    signal_4(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.05) --pick_23\n    sim.setJointTargetPosition(joint02,sety+0.15)\n    signal_5(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.05) --pick_24\n    sim.setJointTargetPosition(joint02,sety+0.05)\n    signal_6(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(long_t)\n     -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setpx+0.1)--fall 19\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint02,setpy+0.1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_1(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx)--fall 20\n    sim.setJointTargetPosition(joint02,setpy+0.1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_2(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx)--fall 21\n    sim.setJointTargetPosition(joint02,setpy)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_3(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx)--fall 22\n    sim.setJointTargetPosition(joint02,setpy-0.1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_4(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.1)--fall 23\n    sim.setJointTargetPosition(joint02,setpy-0.1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_5(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.1)--fall 24\n    sim.setJointTargetPosition(joint02,setpy-0)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_6(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) \n    sim.setJointTargetPosition(joint02,sety)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setx+0.05) --pick_25\n    sim.setJointTargetPosition(joint02,sety-0.05)\n    signal_1(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.05) --pick_26 \n    sim.setJointTargetPosition(joint02,sety-0.15)\n    signal_2(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.15) --pick_27\n    sim.setJointTargetPosition(joint02,sety-0.15)\n    signal_3(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.15) --pick_28\n    sim.setJointTargetPosition(joint02,sety-0.05)\n    signal_4(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.15) --pick_29\n    sim.setJointTargetPosition(joint02,sety+0.05)\n    signal_5(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.15) --pick_30\n    sim.setJointTargetPosition(joint02,sety+0.15)\n    signal_6(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(long_long_t)\n     -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setpx-0.1)--fall 25\n    sim.wait(long_long_t)\n    sim.setJointTargetPosition(joint02,setpy+0.1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_1(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.05)--fall 26\n    sim.setJointTargetPosition(joint02,setpy+0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h2)\n    sim.wait(tt)\n    signal_2(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.05)--fall 27\n    sim.setJointTargetPosition(joint02,setpy-0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h2)\n    sim.wait(tt)\n    signal_3(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.05)--fall 28\n    sim.setJointTargetPosition(joint02,setpy-0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h2)\n    sim.wait(tt)\n    signal_4(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.05)--fall 29\n    sim.setJointTargetPosition(joint02,setpy+0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h2)\n    sim.wait(tt)\n    signal_5(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx)--fall 30\n    sim.setJointTargetPosition(joint02,setpy)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h1)\n    sim.wait(tt)\n    signal_6(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    ----------------------------------------------\n    sim.setJointTargetPosition(joint01,0) \n    sim.setJointTargetPosition(joint02,0)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    -----------------------------------------------------------\n    -----------------------------------------------------------\n    -----------------------------------------------------------\n    pick_h1=0.07\n    pick_h2=0.138\n    pick_h3=0.2085\n    pick_h4=0.28\n    setx=-0.51\n    setpx=0.49\n    signal_1(true)\n    sim.setJointTargetPosition(joint01,setx) --pick_1\n    sim.setJointTargetPosition(joint02,sety)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.05) --pick_2 h2-h2-\n    sim.setJointTargetPosition(joint02,sety-0.05)\n    sim.wait(tt)\n    signal_2(true)\n    sim.setJointTargetPosition(joint03,aty-pick_h2)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.05) --pick_3\n    sim.setJointTargetPosition(joint02,sety+0.05)\n    sim.wait(tt)\n    signal_3(true)\n    sim.setJointTargetPosition(joint03,aty-pick_h2)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.05) --pick_4\n    sim.setJointTargetPosition(joint02,sety+0.05)\n    sim.wait(tt)\n    signal_4(true)\n    sim.setJointTargetPosition(joint03,aty-pick_h2)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.05) --pick_5\n    sim.setJointTargetPosition(joint02,sety-0.05)\n    sim.wait(tt)\n    signal_5(true)\n    sim.setJointTargetPosition(joint03,aty-pick_h2)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.1) --pick_6 h3-h3\n    sim.setJointTargetPosition(joint02,sety+0.1)\n    sim.wait(tt)\n    signal_6(true)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(long_t)\n    -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setpx-0.15)--fall 1\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint02,setpy+0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_1(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.15)--fall 2\n    sim.setJointTargetPosition(joint02,setpy+0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_2(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.15)--fall 3\n    sim.setJointTargetPosition(joint02,setpy-0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_3(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.15)--fall 4\n    sim.setJointTargetPosition(joint02,setpy-0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_4(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.05)--fall 5\n    sim.setJointTargetPosition(joint02,setpy-0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_5(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.05)--fall 6\n    sim.setJointTargetPosition(joint02,setpy-0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_6(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) \n    sim.setJointTargetPosition(joint02,sety)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setx+0.1) --pick_7\n    sim.setJointTargetPosition(joint02,sety)\n    signal_1(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.1) --pick_8\n    sim.setJointTargetPosition(joint02,sety-0.1)\n    signal_2(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) --pick_9\n    sim.setJointTargetPosition(joint02,sety-0.1)\n    signal_3(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) --pick_10\n    sim.setJointTargetPosition(joint02,sety)\n    signal_4(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) --pick_11\n    sim.setJointTargetPosition(joint02,sety+0.1)\n    signal_5(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.1) --pick_12\n    sim.setJointTargetPosition(joint02,sety+0.1)\n    signal_6(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(long_t)\n     -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setpx-0.05)--fall 7\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint02,setpy+0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_1(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.05)--fall 8\n    sim.setJointTargetPosition(joint02,setpy+0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_2(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-0.12)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.05)--fall 9\n    sim.setJointTargetPosition(joint02,setpy+0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_3(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.05)--fall 10\n    sim.setJointTargetPosition(joint02,setpy+0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_4(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.05)--fall 11\n    sim.setJointTargetPosition(joint02,setpy-0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_5(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.05)--fall 12\n    sim.setJointTargetPosition(joint02,setpy-0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_6(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) \n    sim.setJointTargetPosition(joint02,sety)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setx-0.1) --pick_13\n    sim.setJointTargetPosition(joint02,sety)\n    signal_1(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.1) --pick_14 \n    sim.setJointTargetPosition(joint02,sety-0.1)\n    signal_2(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h3)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.15) --pick_15 --h4-h4\n    sim.setJointTargetPosition(joint02,sety+0.15)\n    signal_3(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.15) --pick_16\n    sim.setJointTargetPosition(joint02,sety+0.05)\n    signal_4(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.15) --pick_17\n    sim.setJointTargetPosition(joint02,sety-0.05)\n    signal_5(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.15) --pick_18\n    sim.setJointTargetPosition(joint02,sety-0.15)\n    signal_6(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(long_long_t)\n    \n     -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setpx+0.15)--fall 13\n    sim.wait(long_long_t)\n    sim.setJointTargetPosition(joint02,setpy-0.15)\n    sim.wait(long_long_t)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_1(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.15)--fall 14\n    sim.setJointTargetPosition(joint02,setpy-0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_2(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.15)--fall 15\n    sim.setJointTargetPosition(joint02,setpy+0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_3(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.15)--fall 16\n    sim.setJointTargetPosition(joint02,setpy+0.15)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4)\n    sim.wait(tt)\n    signal_4(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h4_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.1)--fall 17 h3--h3\n    sim.setJointTargetPosition(joint02,setpy-0.1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_5(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.1)--fall 18\n    sim.setJointTargetPosition(joint02,setpy-0)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_6(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) \n    sim.setJointTargetPosition(joint02,sety)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setx-0.05) --pick_19\n    sim.setJointTargetPosition(joint02,sety-0.15)\n    signal_1(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.05) --pick_20 \n    sim.setJointTargetPosition(joint02,sety-0.05)\n    signal_2(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.05) --pick_21\n    sim.setJointTargetPosition(joint02,sety+0.05)\n    signal_3(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx-0.05) --pick_22\n    sim.setJointTargetPosition(joint02,sety+0.15)\n    signal_4(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.05) --pick_23\n    sim.setJointTargetPosition(joint02,sety+0.15)\n    signal_5(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.05) --pick_24\n    sim.setJointTargetPosition(joint02,sety+0.05)\n    signal_6(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(long_t)\n     -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setpx+0.1)--fall 19\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint02,setpy+0.1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_1(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx)--fall 20\n    sim.setJointTargetPosition(joint02,setpy+0.1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_2(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx)--fall 21\n    sim.setJointTargetPosition(joint02,setpy)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_3(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx)--fall 22\n    sim.setJointTargetPosition(joint02,setpy-0.1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_4(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.1)--fall 23\n    sim.setJointTargetPosition(joint02,setpy-0.1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_5(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.1)--fall 24\n    sim.setJointTargetPosition(joint02,setpy-0)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_6(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx) \n    sim.setJointTargetPosition(joint02,sety)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setx+0.05) --pick_25\n    sim.setJointTargetPosition(joint02,sety-0.05)\n    signal_1(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.05) --pick_26 \n    sim.setJointTargetPosition(joint02,sety-0.15)\n    signal_2(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.15) --pick_27\n    sim.setJointTargetPosition(joint02,sety-0.15)\n    signal_3(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.15) --pick_28\n    sim.setJointTargetPosition(joint02,sety-0.05)\n    signal_4(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.15) --pick_29\n    sim.setJointTargetPosition(joint02,sety+0.05)\n    signal_5(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setx+0.15) --pick_30\n    sim.setJointTargetPosition(joint02,sety+0.15)\n    signal_6(true)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-pick_h4)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(long_long_t)\n     -----------------------------------------------------------\n    sim.setJointTargetPosition(joint01,setpx-0.1)--fall 25\n    sim.wait(long_long_t)\n    sim.setJointTargetPosition(joint02,setpy+0.1)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3)\n    sim.wait(tt)\n    signal_1(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h3_up)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,60*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.05)--fall 26\n    sim.setJointTargetPosition(joint02,setpy+0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h2)\n    sim.wait(tt)\n    signal_2(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,120*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx-0.05)--fall 27\n    sim.setJointTargetPosition(joint02,setpy-0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h2)\n    sim.wait(tt)\n    signal_3(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,180*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.05)--fall 28\n    sim.setJointTargetPosition(joint02,setpy-0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h2)\n    sim.wait(tt)\n    signal_4(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,240*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx+0.05)--fall 29\n    sim.setJointTargetPosition(joint02,setpy+0.05)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h2)\n    sim.wait(tt)\n    signal_5(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,300*math.pi/180)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint01,setpx)--fall 30\n    sim.setJointTargetPosition(joint02,setpy)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty-fall_h1)\n    sim.wait(tt)\n    signal_6(false)\n    sim.wait(tt)\n    sim.setJointTargetPosition(joint03,aty)\n    sim.wait(tt)\n    ----------------------------------------------\n    sim.setJointTargetPosition(joint01,0) \n    sim.setJointTargetPosition(joint02,0)\n    setx=0.5\n    setpx=0.5\n    sim.wait(tt)\n    sim.setJointTargetPosition(jointr,0*math.pi/180)\n    sim.wait(tt)\n    -----------------------------------------------------------\n    end\nend\n\nfunction sysCall_cleanup()\n    -- Put some clean-up code here\nend\n\n-- See the user manual or the available code snippets for additional callback functions and details\n \n \n 吸盤程式 \n function sysCall_init() \n    modelBase1=sim.getObjectAssociatedWithScript(sim.handle_self)\n    robotBase1=modelBase1\n    while true do\n        robotBase1=sim.getObjectParent(robotBase1)\n        if robotBase1==-1 then\n            robotName1=\'Base\'\n            break\n        end\n        robotName1=sim.getObjectName(robotBase1)\n        suffix,suffixlessName=sim.getNameSuffix(robotName1)\n        if suffixlessName==\'Base\' then\n            break\n        end\n    end\n    sa=sim.getObjectHandle(\'suctionPadSensor\')\n    la=sim.getObjectHandle(\'suctionPadLoopClosureDummy1\')\n    l2a=sim.getObjectHandle(\'suctionPadLoopClosureDummy2\')\n    ba=sim.getObjectHandle(\'suctionPad\')\n    suctionPadLink=sim.getObjectHandle(\'suctionPadLink\')\n    local gripperBase=sim.getObjectAssociatedWithScript(sim.handle_self)\n\n    infiniteStrength=sim.getScriptSimulationParameter(sim.handle_self,\'infiniteStrength\')\n    maxPullForce=sim.getScriptSimulationParameter(sim.handle_self,\'maxPullForce\')\n    maxShearForce=sim.getScriptSimulationParameter(sim.handle_self,\'maxShearForce\')\n    maxPeelTorque=sim.getScriptSimulationParameter(sim.handle_self,\'maxPeelTorque\')\n\n    sim.setLinkDummy(la,-1)\n    sim.setObjectParent(la,ba,true)\n    ma=sim.getObjectMatrix(l2a,-1)\n    sim.setObjectMatrix(la,-1,ma)\nend\n\n\nfunction sysCall_cleanup() \n    sim.setLinkDummy(la,-1)\n    sim.setObjectParent(la,ba,true)\n    ma=sim.getObjectMatrix(l2a,-1)\n    sim.setObjectMatrix(la,-1,ma)\nend \n\nfunction sysCall_sensing() \n    parent=sim.getObjectParent(la)\n    local sig=sim.getIntegerSignal(robotName1 .."call_1")\n    if (not sig) or (sig==0) then\n        if (parent~=ba) then\n            sim.setLinkDummy(la,-1)\n            sim.setObjectParent(la,ba,true)\n            ma=sim.getObjectMatrix(l2a,-1)\n            sim.setObjectMatrix(la,-1,ma)\n        end\n    else\n        if (parent==ba) then\n            -- Here we want to detect a respondable shape, and then connect to it with a force sensor (via a loop closure dummy dummy link)\n            -- However most respondable shapes are set to "non-detectable", so "sim.readProximitySensor" or similar will not work.\n            -- But "sim.checkProximitySensor" or similar will work (they don\'t check the "detectable" flags), but we have to go through all shape objects!\n            index=0\n            while true do\n                shape=sim.getObjects(index,sim.object_shape_type)\n                if (shape==-1) then\n                    break\n                end\n                if (shape~=ba) and (sim.getObjectInt32Parameter(shape,sim.shapeintparam_respondable)~=0) and (sim.checkProximitySensor(sa,shape)==1) then\n                    -- Ok, we found a respondable shape that was detected\n                    -- We connect to that shape:\n                    -- Make sure the two dummies are initially coincident:\n                    sim.setObjectParent(la,ba,true)\n                    ma=sim.getObjectMatrix(l2a,-1)\n                    sim.setObjectMatrix(la,-1,ma)\n                    -- Do the connection:\n                    sim.setObjectParent(la,shape,true)\n                    sim.setLinkDummy(la,l2a)\n                    break\n                end\n                index=index+1\n            end\n        else\n            -- Here we have an object attached\n            if (infiniteStrength==false) then\n                -- We might have to conditionally beak it apart!\n                result,force,torque=sim.readForceSensor(suctionPadLink) -- Here we read the median value out of 5 values (check the force sensor prop. dialog)\n                if (result>0) then\n                    breakIt=false\n                    if (force[3]>maxPullForce) then breakIt=true end\n                    sf=math.sqrt(force[1]*force[1]+force[2]*force[2])\n                    if (sf>maxShearForce) then breakIt=true end\n                    if (torque[1]>maxPeelTorque) then breakIt=true end\n                    if (torque[2]>maxPeelTorque) then breakIt=true end\n                    if (breakIt) then\n                        -- We break the link:\n                        sim.setLinkDummy(la,-1)\n                        sim.setObjectParent(la,ba,true)\n                        ma=sim.getObjectMatrix(l2a,-1)\n                        sim.setObjectMatrix(la,-1,ma)\n                    end\n                    \n                end\n            end\n        end\n    end\nend \n \n \n', 'tags': '', 'url': '舊版本.html'}, {'title': '尋找控制代碼', 'text': "coppeliasim中 \n simGetSimulatorMessage()為讀取鍵盤狀態的指令 \n 但是我們不知道指令是甚麼，所以寫了一段程式來檢測看每一個按鍵的指令是什麼 \n 所以寫了這一支程式來檢測每一個按鈕的值 \n 在coppeliaSim中叫出一個物件，然後對那個物件編寫程式如下 \n 開始模擬後按下鍵盤鍵即可在下方視窗顯示對應的按鍵 \n \n 程式碼如下 \n function sysCall_actuation()\n    message,auxiliaryData=simGetSimulatorMessage()\n\twhile message~=-1 do\n\t\tif (message==sim_message_keypress) then\n\t\t\tprint(auxiliaryData[1])\n\t\t\tif (auxiliaryData[1]==string.byte(' ')) then\n\t\t\t\t-- space key was pressed\n\t\t\tend\n\t\tend\n\t\tmessage,auxiliaryData=simGetSimulatorMessage()\n\tend\nend \n \n", 'tags': '', 'url': '尋找控制代碼.html'}, {'title': '控制解說', 'text': '5/11 \n 方向鍵上,下，控制大臂的上下移動 \n 方向鍵左,右，控制底座的旋轉 \n 小鍵盤2,8 控制小臂上下移動 \n 小鍵盤4,6 控制小臂的旋轉 \n 小鍵盤1,3 控制手腕的轉動 \n 小鍵盤0 控制小臂是否與大臂連動 \n \n \n', 'tags': '', 'url': '控制解說.html'}, {'title': '0513 機械手臂新增夾爪控制', 'text': '\n 新增一夾爪與兩個攝影機 \n 夾爪可以夾取物品，攝影機可以方便對正要夾取的物品 \n 圖檔: \n Camera contral.ttt \n 參考影片 \n \n \n', 'tags': '', 'url': '0513 機械手臂新增夾爪控制.html'}, {'title': '0511 Programming in C++', 'text': '圖檔: \n programmingl in C++ Unclear.ttt \n 簡介: \n 目前還尚未寫出(5/11)，在編譯上還有問題，問題跟"remoteAPI in C++"中的問題一樣 \n 並且尚未能找到能改語言的方法 \n \n \n \n', 'tags': '', 'url': '0511 Programming in C++.html'}, {'title': '參考資料', 'text': 'coppeliasim 說明書 \n https://www.coppeliarobotics.com/helpFiles/index.html \n coppeliasim 官方教學 \n https://www.coppeliarobotics.com/helpFiles/index.html \n coppeliasim tutorial on youtube(播放清單 \n https://www.youtube.com/watch?v=WJrqt27cYrU&list=PLjzuoBhdtaXOoqkJUqhYQletLLnJP8vjZ&index=3 \n Lua 程式指令 \n https://www.coppeliarobotics.com/helpFiles/index.html \n coppeliasim suctionPad \n https://www.youtube.com/watch?v=vRi2Up0yfyk&t=1927s \n Python remoteApi: \n https://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm \n C++ remoteApi 系統設定: \n https://blog.csdn.net/weixin_44745263/article/details/104555135 \n github 範例: \n https://github.com/orivaldosantana/GPRo \n coppeliasim 相關論壇 (參考內容太多，故僅列論壇首頁 \n https://forum.coppeliarobotics.com/index.php \n coppeliasim 教學部落格 \n https://www.jianshu.com/u/1e3e366da998 \n \n \n', 'tags': '', 'url': '參考資料.html'}, {'title': '舊資料', 'text': '', 'tags': '', 'url': '舊資料.html'}, {'title': '0511 Programming in Lua on multiple program', 'text': '圖檔下載 \n programming in Lua in multiple program.ttt \n 簡介: \n 最基本的控制 \n 在單一軸上對單一軸做程式控制 \n 優點: 程式簡單，變數少 \n 缺點: 要修改程式不易，有幾個程式就需要修改幾次 \n \n \n \n \n \n', 'tags': '', 'url': '0511 Programming in Lua on multiple program.html'}, {'title': '0511 Programming in Lua in One program', 'text': '圖檔 \n programming in Lua in One program.ttt \n 簡介 \n 使用單一程式進行控制 \n 優點: 程式只有一個，所以可以在編寫上比較輕鬆 \n 缺點: 程式較長，尋找特定函式較不易，變數較多程式控制還多，命名上須留意 \n \n \n \n', 'tags': '', 'url': '0511 Programming in Lua in One program.html'}, {'title': 'Python remoteAPI', 'text': '在python的remoteApi 已經有整理資源包在下列倉儲了 \n 只要寫完程式並且儲存在那個資源包裡面 \n https://github.com/Blinhy0131/python-remoteApi \n 即可順利完成 \n 註:建議使用Coppeliasim4.1進行編輯模擬 \n 4.1相對4.2 有比較多的自由度可以編輯 \n', 'tags': '', 'url': 'Python remoteAPI.html'}, {'title': '機械手臂多人對戰', 'text': '圖檔下載 \n robot arm fight \n 場景設定: \n 需到根目錄之 remoteApiConnections.txt在最下方新增以下文字 \n portIndex2_port             = 19998\nportIndex2_debug            = false\nportIndex2_syncSimTrigger   = true \n 然後需要打開cmd 輸入ipconfig 查看ipv4位置 \n 再打開兩個主控程式將ipv4位置填入 \n 示範影片 \n \n \n 構想來源 \n \n \n', 'tags': '', 'url': '機械手臂多人對戰.html'}, {'title': '自動吹笛子機', 'text': 'Stage1-bg6 自動吹笛子機remoteApi \n 控制: \n f,d,s,j,k,l 分別控制六根不同的桿子往下 \n r,e,w,u,i,o 控制六根桿子往上 \n \n 下載 \n 吹笛子程式.rar \n 自動吹笛子remoteApi.ttt \n 參考影片 \n \n 程式參考 \n import sim as vrep\nimport math\nimport random\nimport time\nimport keyboard\nimport math\n#from winsound import Beep\n\n \nprint (\'Start\')\n \n\nvrep.simxFinish(-1)\n\nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\n \nif clientID != -1:\n    print (\'Connected to remote API server\')\n     \n    res = vrep.simxAddStatusbarMessage(\n        clientID, "test-25",\n        vrep.simx_opmode_oneshot)\n    if res not in (vrep.simx_return_ok, vrep.simx_return_novalue_flag):\n        print("Could not add a message to the status bar.")\n \n    \n    opmode = vrep.simx_opmode_oneshot_wait\n    STREAMING = vrep.simx_opmode_streaming\n \n    \n    vrep.simxStartSimulation(clientID, opmode)\n    ret,joint1=vrep.simxGetObjectHandle(clientID,"Revolute3_1",opmode)\n    ret,joint2=vrep.simxGetObjectHandle(clientID,"Revolute3_2",opmode)\n    ret,joint3=vrep.simxGetObjectHandle(clientID,"Revolute3_3",opmode)\n    ret,joint4=vrep.simxGetObjectHandle(clientID,"Revolute3_4",opmode)\n    ret,joint5=vrep.simxGetObjectHandle(clientID,"Revolute3_5",opmode)\n    ret,joint6=vrep.simxGetObjectHandle(clientID,"Revolute3_6",opmode)\n\n    ret,joint01=vrep.simxGetObjectHandle(clientID,"joint0_1",opmode)\n    ret,joint02=vrep.simxGetObjectHandle(clientID,"joint0_2",opmode)\n    ret,joint03=vrep.simxGetObjectHandle(clientID,"joint0_3",opmode)\n    ret,joint04=vrep.simxGetObjectHandle(clientID,"joint0_4",opmode)\n    ret,joint05=vrep.simxGetObjectHandle(clientID,"joint0_5",opmode)\n    ret,joint06=vrep.simxGetObjectHandle(clientID,"joint0_6",opmode)\n\n    degr=-12*math.pi/180\n    py=0.05\n    set1=False\n    set2=False\n    set3=False\n    set4=False\n    set5=False\n    set6=False\n\n    vrep.simxSetJointTargetPosition(clientID,joint1,0,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint01,0,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint2,0,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint02,0,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint3,0,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint03,0,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint4,0,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint04,0,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint5,0,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint05,0,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint6,0,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint06,0,opmode)\n\n    while True:\n        \n        if keyboard.is_pressed("f"):\n            if set1==False:\n                vrep.simxSetJointTargetPosition(clientID,joint1,degr,opmode)\n                vrep.simxSetJointTargetPosition(clientID,joint01,py,opmode)\n                set1=True\n        if keyboard.is_pressed("d"):\n            if set2==False:\n                vrep.simxSetJointTargetPosition(clientID,joint2,degr,opmode)\n                vrep.simxSetJointTargetPosition(clientID,joint02,py,opmode)\n                set2=True\n        if keyboard.is_pressed("s"):\n            if set3==False:\n                vrep.simxSetJointTargetPosition(clientID,joint3,degr,opmode)\n                vrep.simxSetJointTargetPosition(clientID,joint03,py,opmode)\n                set3=True\n        if keyboard.is_pressed("j"):\n            if set4==False:\n                vrep.simxSetJointTargetPosition(clientID,joint4,degr,opmode)\n                vrep.simxSetJointTargetPosition(clientID,joint04,py,opmode)\n                set4=True\n        if keyboard.is_pressed("k"):\n            if set5==False:\n                vrep.simxSetJointTargetPosition(clientID,joint5,degr,opmode)\n                vrep.simxSetJointTargetPosition(clientID,joint05,py,opmode)\n                set5=True\n        if keyboard.is_pressed("l"):\n            if set6==False:\n                vrep.simxSetJointTargetPosition(clientID,joint6,degr,opmode)\n                vrep.simxSetJointTargetPosition(clientID,joint06,py,opmode)\n                set6=True\n\n        \n        if keyboard.is_pressed("r"):\n            if set1==True:\n                vrep.simxSetJointTargetPosition(clientID,joint1,0,opmode)\n                vrep.simxSetJointTargetPosition(clientID,joint01,0,opmode)\n                set1=False\n        if keyboard.is_pressed("e"):\n            if set2==True:\n                vrep.simxSetJointTargetPosition(clientID,joint2,0,opmode)\n                vrep.simxSetJointTargetPosition(clientID,joint02,0,opmode)\n                set2=False\n        if keyboard.is_pressed("w"):\n            if set3==True:\n                vrep.simxSetJointTargetPosition(clientID,joint3,0,opmode)\n                vrep.simxSetJointTargetPosition(clientID,joint03,0,opmode)\n                set3=False\n        if keyboard.is_pressed("u"):\n            if set4==True:\n                vrep.simxSetJointTargetPosition(clientID,joint4,0,opmode)\n                vrep.simxSetJointTargetPosition(clientID,joint04,0,opmode)\n                set4=False\n        if keyboard.is_pressed("i"):\n            if set5==True:\n                vrep.simxSetJointTargetPosition(clientID,joint5,0,opmode)\n                vrep.simxSetJointTargetPosition(clientID,joint05,0,opmode)\n                set5=False\n        if keyboard.is_pressed("o"):\n            if set6==True:\n                vrep.simxSetJointTargetPosition(clientID,joint6,0,opmode)\n                vrep.simxSetJointTargetPosition(clientID,joint06,0,opmode)\n                set6=False\n        \n        #if(set1==true ):\n            #Beep(422, 3000) \n        \n \n \nelse:\n    print (\'Failed connecting to remote API server\')\n    print (\'End\') \n \n \n', 'tags': '', 'url': '自動吹笛子機.html'}, {'title': '3D列印機', 'text': '使用python remoteApi進行遠端控制 \n 控制: \n 上下左右控制噴頭的上下左右 \n 空白鍵往上 \n C鍵往下 \n 圖檔 \n 3D print remoteApi program \n 3D print remoteApi.ttt \n \n 程式參考 \n 5/18 程式修改:將顯示的數值由公尺轉成毫米並且去掉多餘的小數點 \n import sim as vrep\nimport math\nimport random\nimport time\nimport keyboard\n \nprint (\'Start\')\n \n# Close eventual old connections\nvrep.simxFinish(-1)\n\n# Connect to V-REP remote server\nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\n \nif clientID != -1:\n    print (\'Conipconfigected to remote API server\')\n    \n    res = vrep.simxAddStatusbarMessage(\n        clientID, "40823214",\n        vrep.simx_opmode_oneshot)\n    if res not in (vrep.simx_return_ok, vrep.simx_return_novalue_flag):\n        print("Could not add a message to the status bar.")\n \n\n    opmode = vrep.simx_opmode_oneshot_wait\n    STREAMING = vrep.simx_opmode_streaming\n\n    vrep.simxStartSimulation(clientID, opmode)\n\n    ret,joint1=vrep.simxGetObjectHandle(clientID,"X",opmode)\n    ret,joint2=vrep.simxGetObjectHandle(clientID,"Y",opmode)\n    ret,joint3=vrep.simxGetObjectHandle(clientID,"Z",opmode)\n    dx=0\n    dy=0\n    dz=0\n    dt=0.005\n    cont=0\n    rangeR=0.013\n    max_h=0.35\n    vrep.simxSetJointTargetPosition(clientID,joint1,dx,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint2,dx,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint3,dx,opmode)\n\n    while True:\n        #Clockwise\n        if keyboard.is_pressed("8"):\n            dx=dx+dt\n            cont=float(math.pow(dx,2)+math.pow(dy,2))\n            if cont<rangeR:\n                vrep.simxSetJointTargetPosition(clientID,joint1,dx,opmode)\n                print(round(dx*1000,1),round(dy*1000,1),round(dz*1000,1))\n            else:\n                print("Out of range")\n                dx=dx-dt\n        if keyboard.is_pressed("2"):\n            dx=dx-dt\n            cont=float(math.pow(dx,2)+math.pow(dy,2))\n            if cont<rangeR:\n                vrep.simxSetJointTargetPosition(clientID,joint1,dx,opmode)\n                print(round(dx*1000,1),round(dy*1000,1),round(dz*1000,1))\n            else:\n                print("Out of range")\n                dx=dx+dt\n        if keyboard.is_pressed("4"):\n            dy=dy+dt\n            cont=float(math.pow(dx,2)+math.pow(dy,2))\n            if cont<rangeR:\n                vrep.simxSetJointTargetPosition(clientID,joint2,dy,opmode)\n                print(round(dx*1000,1),round(dy*1000,1),round(dz*1000,1))\n            else:\n                print("Out of range")\n                dy=dy-dt\n        if keyboard.is_pressed("6"):\n            dy=dy-dt\n            cont=float(math.pow(dx,2)+math.pow(dy,2))\n            if cont<rangeR:\n                vrep.simxSetJointTargetPosition(clientID,joint2,dy,opmode)\n                print(round(dx*1000,1),round(dy*1000,1),round(dz*1000,1))\n            else:\n                print("Out of range")\n                dy=dy+dt\n        if keyboard.is_pressed("space"):    \n            dz=dz+dt   \n            if dz<max_h:       \n                vrep.simxSetJointTargetPosition(clientID,joint3,dz,opmode)\n                print(round(dx*1000,1),round(dy*1000,1),round(dz*1000,1))\n            else:\n                print("too high")\n                dz=dz-dt \n        if keyboard.is_pressed("c"):\n            dz=dz-dt\n            if dz<0:\n                print("too low")\n                dz=0\n            else:\n                vrep.simxSetJointTargetPosition(clientID,joint3,dz,opmode)\n                print(round(dx*1000,1),round(dy*1000,1),round(dz*1000,1))\n    else:\n        print (\'Failed connecting to remote API server\')\n        print (\'End\') \n \n', 'tags': '', 'url': '3D列印機.html'}, {'title': 'W13 Pick and Place remoteApi', 'text': '', 'tags': '', 'url': 'W13 Pick and Place remoteApi.html'}, {'title': '0601', 'text': '圖檔參考 \n Pick and Place \n 角度控制解說 \n https://40823225.github.io/stage3-bg6/content/%E8%A8%88%E7%AE%97%E8%A7%92%E5%BA%A6.html \n 影片參考 \n \n 程式參考(python remoteApi) \n import sim as vrep\nimport math\nimport random\nimport time\nimport math\n\ndef rotate_motor(x,y,z,switch):\n    x=float(x)\n    y=float(y)\n    z=float(z)\n    deg1=math.atan(x/(1.415-y))\n    x=1.415-(1.415-y)/math.cos(deg1)\n    length=math.pow((math.pow(0.2,2)+math.pow(1.082,2)),0.5)\n    distance=math.pow((math.pow(1.082-x,2)+math.pow(0.96-z,2)),0.5)\n    perimeter=(length+distance+0.76)/2\n    area=math.pow(perimeter*(perimeter-length)*(perimeter-distance)*(perimeter-0.76),0.5)\n    high=2*area/distance\n    joint2_after_sita=math.asin(high/0.76)\n    joint2_zero_sita=math.atan((1.082-x)/(0.96-z))\n    deg2=joint2_after_sita-joint2_zero_sita\n    joint3_base=math.atan(1.082/0.2)\n    angle_joint3=math.acos(high/length)\n    deg3=(90*math.pi/180)+joint2_after_sita-angle_joint3-joint3_base\n    deg4=deg2-deg3\n    if switch==1:\n        vrep.simxSetJointTargetPosition(clientID,joint01,deg1,opmode)\n        vrep.simxSetJointTargetPosition(clientID,joint02,deg2,opmode)\n        vrep.simxSetJointTargetPosition(clientID,joint03,(-deg3),opmode)\n        vrep.simxSetJointTargetPosition(clientID,joint04,(-deg4),opmode)\n    if switch==2:\n        vrep.simxSetJointTargetPosition(clientID,joint03,(-deg3),opmode)\n        time.sleep(0.2)\n        vrep.simxSetJointTargetPosition(clientID,joint01,deg1,opmode)\n        vrep.simxSetJointTargetPosition(clientID,joint02,deg2,opmode)\n        vrep.simxSetJointTargetPosition(clientID,joint04,(-deg4),opmode)\n\ndef signal_switch(singal):\n\n    if singal==1 :\n        vrep.simxSetIntegerSignal(clientID,"call_1",1,opmode) #here might have a error\n    if singal==2 :\n        vrep.simxSetIntegerSignal(clientID,"call_2",1,opmode)\n    if singal==3 :\n        vrep.simxSetIntegerSignal(clientID,"call_3",1,opmode)\n    if singal==4 :\n        vrep.simxSetIntegerSignal(clientID,"call_4",1,opmode)\n    if singal==5 :\n        vrep.simxSetIntegerSignal(clientID,"call_5",1,opmode)\n    if singal==6 :\n        vrep.simxSetIntegerSignal(clientID,"call_6",1,opmode)\n    if singal==12:\n        vrep.simxSetIntegerSignal(clientID,\'call_1\',0,opmode) #here might have a error\n    if singal==11:\n        vrep.simxSetIntegerSignal(clientID,"call_2",0,opmode)\n    if singal==10:\n        vrep.simxSetIntegerSignal(clientID,"call_3",0,opmode)\n    if singal==9:\n        vrep.simxSetIntegerSignal(clientID,"call_4",0,opmode)\n    if singal==8:\n        vrep.simxSetIntegerSignal(clientID,"call_5",0,opmode)\n    if singal==7:\n        vrep.simxSetIntegerSignal(clientID,"call_6",0,opmode)\n\ndef clean():\n    vrep.simxSetIntegerSignal(clientID,"call_1",0,opmode)\n    vrep.simxSetIntegerSignal(clientID,"call_2",0,opmode)\n    vrep.simxSetIntegerSignal(clientID,"call_3",0,opmode)\n    vrep.simxSetIntegerSignal(clientID,"call_4",0,opmode)\n    vrep.simxSetIntegerSignal(clientID,"call_5",0,opmode)\n    vrep.simxSetIntegerSignal(clientID,"call_6",0,opmode)\n\nprint (\'Start\')\n \nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\n  \nif clientID != -1:\n    print (\'Connected to remote API server\')\n      \n    res = vrep.simxAddStatusbarMessage(\n        clientID, "pad testing",\n        vrep.simx_opmode_oneshot)\n    if res not in (vrep.simx_return_ok, vrep.simx_return_novalue_flag):\n        print("Could not add a message to the status bar.")\n  \n     \n    opmode = vrep.simx_opmode_oneshot_wait\n    STREAMING = vrep.simx_opmode_streaming\n  \n     \n    vrep.simxStartSimulation(clientID, opmode)\n    ret,joint01=vrep.simxGetObjectHandle(clientID,"joint1",opmode)\n    ret,joint02=vrep.simxGetObjectHandle(clientID,"joint2",opmode)\n    ret,joint03=vrep.simxGetObjectHandle(clientID,"joint3",opmode)\n    ret,joint04=vrep.simxGetObjectHandle(clientID,"joint4",opmode)\n    ret,jointr=vrep.simxGetObjectHandle(clientID,"Rotate",opmode)\n    tt=1.5\n    long_t=3\n    long_long_t=3 #time set\n    rotate_deg=0 #pad rotate\n    atz=0  #altitude set\n    setx=-0.5\n    setpx=0.5 #center pick set\n    sety=0.16\n    setpy=0.16 #center fall set\n    cube=1              # set cube\n    ball_pick_time=0    #total ball we pick\n    ball_put_time=31     #total ball we put\n    put_cont=0          # print the ball we put\n    pick_high=[\'0.0645\',\'0.134\',\'0.202\',\'0.2785\'] #pick up high set\n    fall_high=[\'0.05\',\'0.12\',\'0.18\',\'0.26\'] #fall high set\n    high_up=[\'0\',\'0\',\'0.05\',\'0.12\']\n\n    \n    \n\n    while True :\n        clean() #clean all the \n        vrep.simxSetJointTargetPosition(clientID,joint01,0,opmode)\n        vrep.simxSetJointTargetPosition(clientID,joint02,0,opmode)\n        vrep.simxSetJointTargetPosition(clientID,joint03,0,opmode)\n        vrep.simxSetJointTargetPosition(clientID,joint04,0,opmode)\n        vrep.simxSetJointTargetPosition(clientID,jointr,0,opmode)\n        time.sleep(tt)\n        for ball in range(1,7,1):\n            ball_pick_time=ball_pick_time+1 #total time we pick\n            i=1\n            unit=0\n            level=0\n            while level < ball_pick_time :  #find which level and place should be of the xy coordinates\n                unit=unit+1\n                level=level+unit**2\n            finding_XY=ball_pick_time  #this is the XY on that floor\n            while i<=unit-1:\n                finding_XY=finding_XY-(i**2) \n                i=i+1\n            X_Pos=finding_XY%unit  #the X and Y coordinates(by balls)\n            if X_Pos==0:\n                X_Pos=unit\n            Y_Pos=(math.ceil(finding_XY/unit)) \n            BaseX=setx-((unit-1)*0.05)#now we need to find the 0 of the xy\n            BaseY=sety-((unit-1)*0.05)\n            #vrep.simxSetJointTargetPosition(clientID,joint01,BaseX+(0.1*(X_Pos-1)),opmode)\n            #time.sleep(tt)\n            rotate_motor(BaseX+(0.1*(X_Pos-1)),BaseY+(0.1*(Y_Pos-1)),high_up[(unit-1)],1)\n            time.sleep(tt)\n            print("Picking up the ball nember",ball_pick_time,"...")\n            signal_switch(ball)\n            rotate_motor(BaseX+(0.1*(X_Pos-1)),BaseY+(0.1*(Y_Pos-1)),pick_high[(unit-1)],1)\n            time.sleep(tt)\n            rotate_motor(BaseX+(0.1*(X_Pos-1)),BaseY+(0.1*(Y_Pos-1)),high_up[(unit-1)],2)\n            time.sleep(tt)\n            rotate_deg=rotate_deg+60\n            vrep.simxSetJointTargetPosition(clientID,jointr,rotate_deg*math.pi/180,opmode)\n            time.sleep(tt)\n        vrep.simxSetJointTargetPosition(clientID,joint01,0,opmode)\n        vrep.simxSetJointTargetPosition(clientID,joint02,0,opmode)\n        vrep.simxSetJointTargetPosition(clientID,joint03,0,opmode)\n        vrep.simxSetJointTargetPosition(clientID,joint04,0,opmode)\n        vrep.simxSetJointTargetPosition(clientID,jointr,0,opmode)\n        time.sleep(tt)\n        for ball in range(1,7,1):\n            ball_put_time=ball_put_time-1 #total time we put\n            put_cont=put_cont+1\n            i=1\n            unit=0\n            level=0\n            while level < ball_put_time :\n                unit=unit+1\n                level=level+unit**2\n            finding_XY=ball_put_time \n            while i<=unit-1:\n                finding_XY=finding_XY-(i**2) \n                i=i+1\n            X_Pos=finding_XY%unit\n            if X_Pos==0:\n                X_Pos=unit\n            Y_Pos=(math.ceil(finding_XY/unit)) \n            BaseX=setpx-((unit-1)*0.05)#now we need to find the 0 of the xy\n            BaseY=setpy-((unit-1)*0.05)\n            rotate_deg=rotate_deg-60\n            vrep.simxSetJointTargetPosition(clientID,jointr,rotate_deg*math.pi/180,opmode)\n            time.sleep(tt)\n            rotate_motor(BaseX+(0.1*(X_Pos-1)),BaseY+(0.1*(Y_Pos-1)),high_up[(unit-1)],1)\n            time.sleep(tt)\n            print("Putting the ball nember",put_cont,"...")\n            rotate_motor(BaseX+(0.1*(X_Pos-1)),BaseY+(0.1*(Y_Pos-1)),fall_high[(unit-1)],1)\n            time.sleep(tt)\n            signal_switch((ball+6))\n            time.sleep(0.5)\n            rotate_motor(BaseX+(0.1*(X_Pos-1)),BaseY+(0.1*(Y_Pos-1)),high_up[(unit-1)],1)\n            time.sleep(tt)\n        if ball_pick_time==30:\n            pick_high=[\'0.07\',\'0.135\',\'0.207\',\'0.278\']\n            setx=-setx\n            setpx=-setpx\n            ball_pick_time=0\n            ball_put_time=31\n            put_cont=0 \n \n', 'tags': '', 'url': '0601.html'}, {'title': '0524', 'text': '圖檔 \n W13 Pick and Place \n \n \n', 'tags': '', 'url': '0524.html'}, {'title': 'remoteAPI in C++', 'text': '', 'tags': '', 'url': 'remoteAPI in C++.html'}, {'title': '0511', 'text': '嘗試以C++最為remoteAPI控制的語言 \n compiler為code block in Win10 \n 不論怎麼修改在 \n 後還是出現問題 \n simxGetObjectHandle(clientID, "joint1", &joint01, simx_opmode_oneshot_wait); \n 上程式片段中 \n simx_opmode_oneshot_wait \n 此定義一直出現error，內容如下 \n error: \'simx_opmode_oneshot_wait\' was not declared in this scope \n 中譯:\xa0 simx_opmode_oneshot_wait 定義不明 \n 但是在尋找網路上的範例，寫法也都是如我程式中一樣，目前還在尋找解決方法 \n \n \n 附上程式 \n #include <Windows.h>\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n\nextern "C" {\n    #include "remoteAPI/extApi.h"\n}\n\n\n\nusing namespace std;\n\nint main(){\n    int clientID = 0;\n    simxFinish(-1);\n    clientID = simxStart((simxChar*)"127.0.0.1", 19997, true, true, 5000, 5);\n    Sleep(1);\n    if (clientID != -1)\n    {\n        int joint01;\n        int joint02;\n        int joint03;\n        int joint04;\n        int joint05;\n        simxGetObjectHandle(clientID, "joint1", &joint01, simx_opmode_oneshot_wait);//setting\n        simxGetObjectHandle(clientID, "joint2", &joint02, simx_opmode_oneshot_wait);\n        simxGetObjectHandle(clientID, "joint3", &joint03, simx_opmode_oneshot_wait);\n        simxGetObjectHandle(clientID, "joint4", &joint04, simx_opmode_oneshot_wait);\n        simxGetObjectHandle(clientID, "joint5", &joint05, simx_opmode_oneshot_wait);\n\n\n        float degset01=-11.9;\n        float degset02=34.69;\n        float degset03=-20.2;\n        float degset04=-11.9;\n        float degset05=-11.9;\n        float dif=1;\n\n        //angle set0\n        simxSetJointTargetPosition(clientID,joint01,degset01,simx_opmode_oneshot);\n        simxSetJointTargetPosition(clientID,joint02,degset02,simx_opmode_oneshot);\n        simxSetJointTargetPosition(clientID,joint03,degset03,simx_opmode_oneshot);\n        simxSetJointTargetPosition(clientID,joint04,degset04,simx_opmode_oneshot);\n        simxSetJointTargetPosition(clientID,joint05,degset05,simx_opmode_oneshot);\n        bool balance_contral=true;\n\n\n        clientID,auxiliaryData=simGetSimulatorMessage();\n\n\n        while (clientID!=-1) {\n            if (clientID==simxmessage_keypress) {\n                if (auxiliaryData[1]==2009) { //up Key\n                    degset01=degset01+dif;\n                    simxSetJointTargetPosition(clientID,joint01,degset01,simx_opmode_oneshot);\n                }\n                if (auxiliaryData[1]==2010) { //down key\n                    degset01=degset01-dif;\n                    simxSetJointTargetPosition(clientID,joint01,degset01,simx_opmode_oneshot);\n                }\n                if (auxiliaryData[1]==2007) { //left key\n                    degset02=degset02+dif;\n                    simxSetJointTargetPosition(clientID,joint02,degset02,simx_opmode_oneshot);\n                }\n                if (auxiliaryData[1]==2008) {  //right key\n                    degset02=degset02-dif;\n                    simxSetJointTargetPosition(clientID,joint02,degset02,simx_opmode_oneshot);\n                }\n                if (auxiliaryData[1]==56) { //num8 key\n                    degset03=degset03+dif;\n                    simxSetJointTargetPosition(clientID,joint03,degset03,simx_opmode_oneshot);\n                }\n                if (auxiliaryData[1]==50) { //num2 key\n                    degset03=degset03-dif;\n                    simxSetJointTargetPosition(clientID,joint03,degset03,simx_opmode_oneshot);\n\n                }\n                if (auxiliaryData[1]==54) { //num6 key\n                    degset04=degset04+dif;\n                    simxSetJointTargetPosition(clientID,joint04,degset04,simx_opmode_oneshot);\n                }\n                if (auxiliaryData[1]==52) { //num4 key\n                    degset04=degset04-dif;\n                    simxSetJointTargetPosition(clientID,joint04,degset04,simx_opmode_oneshot);\n                }\n                if (auxiliaryData[1]==49) { //mun1 key\n                    degset05=degset05+dif;\n                    simxSetJointTargetPosition(clientID,joint05,degset05,simx_opmode_oneshot);\n                }\n                if (auxiliaryData[1]==51) { //num3 key\n                    degset05=degset05-dif;\n                    simxSetJointTargetPosition(clientID,joint05,degset05,simx_opmode_oneshot);\n                }\n\n\n\n\n                if  (auxiliaryData[1]==48){ //setting auto Balance at num0 key\n                    if (balance_contral==true){\n                        balance_contral=false;\n                    }else{\n                        balance_contral=true;\n                    }\n                }\n                if (balance_contral==true) {\n                    if (auxiliaryData[1]==2007) {\n                        degset03=degset03+dif ;\n                        simxSetJointTargetPosition(clientID,joint03,degset03,simx_opmode_oneshot);\n                    }\n                    if (auxiliaryData[1]==2008) {\n                        degset03=degset03-dif;\n                        simxSetJointTargetPosition(clientID,joint03,degset03,simx_opmode_oneshot);\n                        }\n                    }\n                }\n        clientID,auxiliaryData=simGetSimulatorMessage();\n        }\n    }\n    simxFinish(clientID);\n    return clientID;\n}\n \n \n', 'tags': '', 'url': '0511.html'}, {'title': '0512', 'text': '後來上網尋找解答發現疑似是complier的問題 \n 於是切換為VS2019進行編譯 \n 並且新增path及include至專案檔 \n 在X64的環境下進行DeBug後 \n 第一個錯誤是這個 \n \n 並且出現以下錯誤 \n \n C4244為警示狀態外，其他錯誤經查詢發現似乎不能啟動"remotaApi.dll"的這個程式 \n \n \n', 'tags': '', 'url': '0512.html'}, {'title': '0512-2', 'text': '後來經過修改與PATH路徑修正 \n 並且將remotaApi所需的標頭檔 \n #include <exApi.h> \n 將其修改程式變成 \n extern "C" {\n   \xa0#include "exApi.h" \n} \n 但是似乎還是一樣 \n \n 目前正在尋找其他解法來修復 \n \n \n', 'tags': '', 'url': '0512-2.html'}, {'title': 'remoteApi in Lua', 'text': '', 'tags': '', 'url': 'remoteApi in Lua.html'}, {'title': '0513', 'text': '.. \n .. \n', 'tags': '', 'url': '0513.html'}, {'title': '個人紀錄', 'text': '. \n', 'tags': '', 'url': '個人紀錄.html'}, {'title': '台中高工畢業專題', 'text': '', 'tags': '', 'url': '台中高工畢業專題.html'}, {'title': 'CoppeliaSim 教學', 'text': '', 'tags': '', 'url': 'CoppeliaSim 教學.html'}, {'title': '軸的旋轉教學', 'text': "\n 注意事項:在旋轉軸中預設的角度單位為弧度(rad) \n 所以在進行旋轉控制的時候要記得轉換成弧度(math.pi/180) \n 程式碼 \n function sysCall_init()\n    -- do some initialization here\n    joint=sim.getObjectHandle('joint01')\nend\n\nfunction sysCall_actuation()\n    -- put your actuation code here\n    sim.setJointTargetPosition(joint,135*math.pi/180)\nend", 'tags': '', 'url': '軸的旋轉教學.html'}, {'title': '直線運動教學', 'text': "\n 程式指令 \n function sysCall_init()\n    -- do some initialization here\n    joint=sim.getObjectHandle('joint')\nend\n\nfunction sysCall_actuation()\n    -- put your actuation code here\n    sim.setJointTargetPosition(joint,50)\nend \n", 'tags': '', 'url': '直線運動教學.html'}, {'title': '1-單軸直線運動', 'text': "\n 程式碼 \n function sysCall_init()\n    -- do some initialization here\n    joint=sim.getObjectHandle('joint')\n    set=0\nend\n \nfunction sysCall_actuation()\n    -- put your actuation code here\n    message,auiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if(message==sim.message_keypress)then\n            if(auiliaryData[1]==2009)then\n                set=set+0.01\n                sim.setJointTargetPosition(joint,set)\n            end\n        end\n    message,auiliaryData=sim.getSimulatorMessage()\n    end\nend \n \n", 'tags': '', 'url': '1-單軸直線運動.html'}, {'title': '2-可變速之旋轉運動', 'text': "\n 程式碼\xa0 (注:下方程式碼有修改 degset(每次旋轉的角度)不會小於1 \n function sysCall_init()\n    -- do some initialization here\n    joint=sim.getObjectHandle('joint')\n    set=0\n    degset=1\nend\n \nfunction sysCall_actuation()\n    -- put your actuation code here\n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then\n            if (auxiliaryData[1]==2009) then\n            set=set+degset\n            sim.setJointTargetPosition(joint,set*math.pi/180)\n            end\n            if (auxiliaryData[1]==2010) then\n            set=set-degset\n            sim.setJointTargetPosition(joint,set*math.pi/180)\n            end\n            if (auxiliaryData[1]==2007) then\n                degset=degset+5\n                print(degset)\n            end\n            if (auxiliaryData[1]==2008) then\n                degset=degset-5\n                if(degset<1) then\n                    degset=1\n                end\n                print(degset)\n            end\n        end\n    message,auxiliaryData=sim.getSimulatorMessage()\n    end\nend\n     \n", 'tags': '', 'url': '2-可變速之旋轉運動.html'}, {'title': '3-遙控攝影小汽車', 'text': "\n 範例程式碼 \n function sysCall_init()\n    -- do some initialization here\n    f=sim.getObjectHandle('F')\n    r=sim.getObjectHandle('R')\n    speedf=10\n    speedr=10\n    Cam1=sim.getObjectHandle('Camera')\n    CamView1=sim.floatingViewAdd(0.2,0.8,0.5,0.5,0)\n    sim.adjustView(CamView1,Cam1,64)\nend\n\nfunction sysCall_cleanup() \n    sim.floatingViewRemove(CamView1)\nend \n \nfunction sysCall_actuation()\n    -- put your actuation code here\n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then\n            if (auxiliaryData[1]==2007) then\n                speedf=speedf-30\n                speedr=speedr-30\n                sim.setJointTargetPosition(f,speedf*math.pi/180)\n                sim.setJointTargetPosition(r,speedr*math.pi/180)\n            end\n            if (auxiliaryData[1]==2008) then\n                speedf=speedf+30\n                speedr=speedr+30\n                sim.setJointTargetPosition(f,speedf*math.pi/180)\n                sim.setJointTargetPosition(r,speedr*math.pi/180)\n            end\n            if (auxiliaryData[1]==2009) then\n                speedr=speedr-30\n                sim.setJointTargetPosition(r,speedr*math.pi/180)\n            end\n            if (auxiliaryData[1]==2010) then\n                speedf=speedf-30\n                sim.setJointTargetPosition(f,speedf*math.pi/180)\n            end\n        end\n    message,auxiliaryData=sim.getSimulatorMessage()\n    end\nend \n \n", 'tags': '', 'url': '3-遙控攝影小汽車.html'}, {'title': 'CODE 指令解說', 'text': '部分LUA指令講解 \n 1.sim.getObjectHandle \n 使用範例如下 \n XXX=sim.getObjectHandle(\'joint\') \n 講解 XXX為一個自行定義的名詞，此指令為定義XXX為一個連接軸，而(\'joint\')為該軸在場景裡面的名稱 \n \n 2.sim.setJointTargetPosition \n 使用範例如下 \n sim.setJointTargetPosition(XXX,90) \n 講解 XXX移動至90這個位置，或旋轉至90rad，XXX請參見第一個指令講解,角度預設為RAD \n 若要需求為旋轉至90deg，指令參考如下 \n sim.setJointTargetPosition(XXX,90*math.pi/180) \n \n 3.sim.getSimulatorMessage \n 使用範例如下 \n message,auxiliaryData=sim.getSimulatorMessage()\nwhile message~=-1 do\n        if (message==sim.message_keypress) then\n            if (auxiliaryData[1]==2009) then\n               指定要做的事情\n            end\n         end\nmessage,auxiliaryData=sim.getSimulatorMessage()\nend\n \n \n 講解 \n 第一行 \n message,auxiliaryData=sim.getSimulatorMessage() \n message代表跟鍵盤對接的狀態 \n auxiliaryData代表讀取到鍵盤的值 \n 第二行的開始 \n 當(while)"message的值不等於-1時 \n 若(if) auxiliaryData讀取到的值為2009 \n 進行要做的事情，可以是上面第二項"sim.setJointTargetPosition"或其他指令 \n 可參考 尋找控制代碼 \n \n 4.simwat \n 使用範例 \n sim.wait(0.01) \n 只能在線程控制中使用(Threaded chil script) \n 為暫停指令，括弧內單位為秒 \n', 'tags': '', 'url': 'CODE 指令解說.html'}, {'title': 'remoteApi python 指令對照', 'text': '1.simxGetObjectHandle \n ret,XXX=vrep.simxGetObjectHandle(clientID,"joint",opmode) \n XXX為一個自行定義的名詞，此指令為定義XXX為一個連接軸，而(\'joint\')為該軸在場景裡面的名稱 \n 與Lua語法類似 \n 2.simxSetJointTargetPosition \n  vrep.simxSetJointTargetPosition(clientID,XXX,90,opmode) \n 講解 XXX移動至90這個位置，或旋轉至90rad，XXX請參見第一個指令講解,角度預設為RAD \n 若要需求為旋轉至90deg，指令參考如下 \n 與Lua語法類似 \n', 'tags': '', 'url': 'remoteApi python 指令對照.html'}, {'title': '機械手臂設定範例', 'text': '\n \n', 'tags': '', 'url': '機械手臂設定範例.html'}, {'title': '按鍵控制代碼', 'text': "\n \n \n 按鍵 \n 對應代碼 \n 按鍵 \n 對應代碼 \n 按鍵 \n 對應代碼 \n 按鍵 \n 對應代碼 \n 按鍵 \n 對應代碼 \n 按鍵 \n 對應代碼 \n \n \n a \n 97 \n j \n 106 \n s \n 115 \n 0 \n 48 \n 9 \n 57 \n . \n 46 \n \n \n b \n 98 \n k \n 107 \n t \n 116 \n 1 \n 49 \n + \n 43 \n ; \n 59 \n \n \n c \n 99 \n l \n 108 \n u \n 117 \n 2 \n 50 \n - \n 45 \n ' \n 39 \n \n \n d \n 100 \n m \n 109 \n v \n 118 \n 3 \n 51 \n * \n 42 \n [ \n 91 \n \n \n e \n 101 \n n \n 110 \n w \n 119 \n 4 \n 52 \n / \n 47 \n ] \n 93 \n \n \n f \n 102 \n o \n 111 \n x \n 120 \n 5 \n 53 \n = \n 61 \n 方向鍵上 \n 2007 \n \n \n g \n 103 \n p \n 112 \n y \n 121 \n 6 \n 54 \n ` \n 96 \n 方向鍵下 \n 2008 \n \n \n h \n 104 \n q \n 113 \n z \n 122 \n 7 \n 55 \n \\ \n 92 \n 方向鍵左 \n 2009 \n \n \n i \n 105 \n r \n 114 \n 空白鍵 \n 32 \n 8 \n 56 \n , \n 44 \n 方向鍵右 \n 2010 \n \n \n \n \n", 'tags': '', 'url': '按鍵控制代碼.html'}, {'title': '期末全班直播教學', 'text': '\n', 'tags': '', 'url': '期末全班直播教學.html'}]};